#Automatic ASCII Shellcode Subtraction Encoder
#Expands on BUGTREE's z3ncoder, which can encode individual 32 bit hex addresses, by taking in a full shellcode payload and outputting assembly
#Written by Elias Augusto
#Coming soon - Options for additional badchars, option to output assembly to a specified file
#Issues - Breaks if shellcode contains null bytes

import argparse
from z3 import *
from colorama import Fore,Back,Style

#Remember to give it a help dialogue and the ability to check if an string length is a multiple of 8
#It can advise padding with nops if not

def solve(b): #BUGTREE's function that sub encodes 32 bit hex addresses in 0xFFFFFFFF format
    s = Solver()
    bad_chars = [ 0x20, 0x80, 0x0A, 0x0D, 0x2F, 0x3A, 0x3F ]
    x, y, z = BitVecs('x y z', 32)
    variables = [x, y, z]

    for var in variables:
        for k in range(0, 32, 8):
            s.add(Extract(k+7, k, var) > BitVecVal(0x20, 8))
            s.add(ULT(Extract(k+7, k, var), BitVecVal(0x80, 8)))
            for c in bad_chars:
                s.add(Extract(k+7, k, var) != BitVecVal(c, 8))

    s.add(x+y+z==b)

    s.check()
    s.model()
    r = []
    for i in s.model():
        r.append(s.model()[i].as_long())

    return r

parser = argparse.ArgumentParser() #Argument that takes shellcode 
parser.add_argument("-s", "--shellcode", type=str,
                    help="Input hex shellcode with a byte length of a multiple of 4. Handles null bytes fine, but I wouldn't risk it.")
args = parser.parse_args()

if not args.shellcode: #Exit if no shellcode given
	parser.print_help()
	parser.exit()
if len(args.shellcode)%8!=0: #Exit if shellcode length is less than 4
	parser.error("Shellcode byte length is not a multiple of 4, pad with nops")

scode=args.shellcode

splitsc=[''.join(x) for x in zip(*[list(scode[z::8]) for z in range(8)])] #Split into fours
print(Fore.GREEN+"\nAutomatic ASCII Shellcode Subtraction Encoder")
print(Fore.GREEN+"Written by Elias Augusto")
print(Fore.GREEN+"Based on BUGTREE's z3ncoder, a single address subtraction encoder")
print(Fore.GREEN+"Assembly output file: aassc.asm")
print(Fore.GREEN+"\n--------------------------------------------------------------------\n")

print(Fore.GREEN+"Original shellcode:\n")
print(Fore.WHITE+'\n'.join(splitsc))

rsplit=[]
for i in range(0,len(splitsc)): #split each line of shellcode, reverse each byte
	fsplit=[''.join(x) for x in zip(*[list(splitsc[i][z::2]) for z in range(2)])]
	lsplit=fsplit[::-1]
	rsplit+=''.join(map(str,lsplit))

unsplit=''.join(rsplit) #Join rsplit into one string
resplit=[''.join(x) for x in zip(*[list(unsplit[z::8]) for z in range(8)])] #split it into strings of 4 bytes again

for i in range(0,len(resplit)):
	resplit[i]="0x"+resplit[i]

reversesc=resplit[::-1] #Reverse the order of the elements to push to the stack

print(Fore.GREEN+"\n--------------------------------------------------------------------\n")
print(Fore.GREEN+"Shellcode Reversed and Formatted for Stack:\n")
print(Fore.WHITE+'\n'.join(reversesc))

hexsc=reversesc
reciporical=[None]*len(hexsc)
for i in range(0,len(hexsc)): #Get the reciporical of every hex string aftr converting it to an int
	hexsc[i]=int(hexsc[i],16)
	f=hexsc[i]
	reciporical[i]=0xFFFFFFFF-f + 1

precip=reciporical
for i in range(0,len(precip)):
	precip[i]=hex(precip[i])
print(Fore.GREEN+"\n--------------------------------------------------------------------\n")
print(Fore.GREEN+"Reciporical of each chunk:\n")
print(Fore.WHITE+'\n'.join(precip))

print(Fore.GREEN+"\n--------------------------------------------------------------------\n")
print(Fore.GREEN+"Assembly Output")
print(Fore.GREEN+"Sent to file aassc.asm:\n")
buffer=";Intel assembly output for NASM\n"
buffer+=";Generated by Automatic ASCII Shellcode Subtraction Encoder\n\n"
buffer+=";Unencoded payload = "+args.shellcode+"\n\n"
buffer+=";Note: You still need to set up the stack yourself, this is just the decoder\n"
buffer+=";(If the verification sum has 9 bytes and begins with 0x1, everything is fine, that's just python)\n\n"

for i in range(0,len(reciporical)): #Assembly output
	sumCheck=0
	result=solve(int(reciporical[i],16))
	for h in result[-3:]:
		sumCheck+=h
	buffer+=";~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
	buffer+=";0xFFFFFFFF - "+hex(reversesc[i])+" + 1 = "+precip[i]+"\n"
	buffer+=";Verified: "+hex(sumCheck)+" = "+precip[i]+"\n\n"
	buffer+="and eax,0x554e4d4a ;normalize eax\n"
	buffer+="and eax,0x2a313235 ;normalize eax\n"
	for h in result[-3:]:
		buffer+="sub eax,"+hex(h)+"\n"
	buffer+="push eax\n\n"
print(Fore.WHITE+buffer)

asmfile=open("aassc.asm","w")
asmfile.write(";aassc.asm\n"+buffer)
asmfile.close()
